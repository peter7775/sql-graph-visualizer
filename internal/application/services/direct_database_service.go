/*
 * SQL Graph Visualizer - Direct Database Connection Service
 *
 * Copyright (c) 2024
 * Licensed under Dual License: AGPL-3.0 OR Commercial License
 * See LICENSE file for details
 * Patent Pending - Application filed for innovative database transformation techniques
 */

package services

import (
	"context"
	"fmt"
	"time"

	"sql-graph-visualizer/internal/application/ports"
	"sql-graph-visualizer/internal/domain/models"

	"github.com/sirupsen/logrus"
)

// DirectDatabaseService orchestrates the entire process of connecting to
// existing databases, analyzing schema, and generating transformation rules
type DirectDatabaseService struct {
	mysqlPort         ports.MySQLPort
	schemaAnalyzer    *SchemaAnalyzerService
	securityValidator *SecurityValidationService
	config            *models.MySQLConfig
}

// NewDirectDatabaseService creates a new direct database service
func NewDirectDatabaseService(
	mysqlPort ports.MySQLPort,
	config *models.MySQLConfig,
) *DirectDatabaseService {

	// Initialize schema analyzer
	schemaConfig := &models.SchemaAnalysisConfig{
		GenerateRules:          config.AutoGeneratedRules.Enabled,
		TableToNode:            true, // Default
		ForeignKeysToRelations: true, // Default
	}

	// Set advanced options if strategy is configured
	if config.AutoGeneratedRules.Strategy != nil {
		schemaConfig.TableToNode = config.AutoGeneratedRules.Strategy.TableToNode
		schemaConfig.ForeignKeysToRelations = config.AutoGeneratedRules.Strategy.ForeignKeysToRelations
		schemaConfig.NamingConvention = config.AutoGeneratedRules.Strategy.NamingConvention
	}
	schemaAnalyzer := NewSchemaAnalyzerService(mysqlPort, schemaConfig)

	// Initialize security validator
	securityValidator := NewSecurityValidationService(&config.Security)

	return &DirectDatabaseService{
		mysqlPort:         mysqlPort,
		schemaAnalyzer:    schemaAnalyzer,
		securityValidator: securityValidator,
		config:            config,
	}
}

// ConnectAndAnalyze performs the complete workflow:
// 1. Security validation of connection parameters
// 2. Connection to existing database
// 3. Schema discovery and analysis
// 4. Transformation rule generation
func (s *DirectDatabaseService) ConnectAndAnalyze(ctx context.Context) (*models.DirectDatabaseAnalysisResult, error) {
	logrus.Infof("Starting direct database connection and analysis workflow")

	result := &models.DirectDatabaseAnalysisResult{
		StartTime:    time.Now(),
		Success:      false,
		DatabaseInfo: &models.DatabaseConnectionInfo{},
	}

	// Step 1: Validate connection security
	logrus.Infof("Step 1: Validating connection security")
	securityResult, err := s.securityValidator.ValidateConnectionSecurity(ctx, s.config)
	if err != nil {
		result.ErrorMessage = fmt.Sprintf("Security validation failed: %v", err)
		result.EndTime = time.Now()
		return result, nil
	}

	result.SecurityValidation = securityResult
	if !securityResult.IsValid {
		result.ErrorMessage = "Connection failed security validation"
		result.EndTime = time.Now()
		return result, nil
	}

	logrus.Infof("Security validation passed (Level: %s)", securityResult.SecurityLevel)

	// Step 2: Establish database connection
	logrus.Infof("Step 2: Connecting to existing database")
	db, err := s.mysqlPort.ConnectToExisting(ctx, s.config)
	if err != nil {
		result.ErrorMessage = fmt.Sprintf("Database connection failed: %v", err)
		result.EndTime = time.Now()
		return result, nil
	}
	defer func() {
		if closeErr := db.Close(); closeErr != nil {
			logrus.Warnf("Failed to close database connection: %v", closeErr)
		}
	}()

	// Step 3: Validate connection and gather info
	logrus.Infof("Step 3: Validating database connection")
	connValidation, err := s.mysqlPort.ValidateConnection(ctx, db)
	if err != nil {
		result.ErrorMessage = fmt.Sprintf("Connection validation failed: %v", err)
		result.EndTime = time.Now()
		return result, nil
	}

	result.ConnectionValidation = connValidation
	if !connValidation.IsValid {
		result.ErrorMessage = "Database connection validation failed"
		result.EndTime = time.Now()
		return result, nil
	}

	// Populate database connection info
	result.DatabaseInfo.Host = s.config.Host
	result.DatabaseInfo.Port = s.config.Port
	result.DatabaseInfo.Database = connValidation.DatabaseInfo["current_database"]
	result.DatabaseInfo.User = connValidation.DatabaseInfo["current_user"]
	result.DatabaseInfo.Version = connValidation.ServerInfo["version"]

	logrus.Infof("Connected to %s (User: %s, Version: %s)",
		result.DatabaseInfo.Database,
		result.DatabaseInfo.User,
		result.DatabaseInfo.Version)

	// Step 4: Analyze database schema
	logrus.Infof("Step 4: Analyzing database schema")
	schemaResult, err := s.schemaAnalyzer.AnalyzeSchemaFromConnection(ctx, db, &s.config.DataFiltering)
	if err != nil {
		result.ErrorMessage = fmt.Sprintf("Schema analysis failed: %v", err)
		result.EndTime = time.Now()
		return result, nil
	}

	result.SchemaAnalysis = schemaResult

	logrus.Infof("Schema analysis completed: %d tables, %d patterns identified, %d rules generated",
		len(schemaResult.Tables),
		len(schemaResult.GraphPatterns),
		len(schemaResult.GeneratedRules))

	// Step 5: Generate summary and recommendations
	logrus.Infof("Step 5: Generating analysis summary")
	s.generateAnalysisSummary(result)

	result.Success = true
	result.EndTime = time.Now()
	result.ProcessingDuration = result.EndTime.Sub(result.StartTime)

	logrus.Infof("Direct database analysis completed successfully in %v", result.ProcessingDuration)

	return result, nil
}

// TestConnection performs a quick connection test without full analysis
func (s *DirectDatabaseService) TestConnection(ctx context.Context) (*models.ConnectionTestResult, error) {
	logrus.Infof("Testing database connection")

	testResult := &models.ConnectionTestResult{
		TestedAt: time.Now(),
		Success:  false,
	}

	securityResult, err := s.securityValidator.ValidateConnectionSecurity(ctx, s.config)
	if err != nil || !securityResult.IsValid {
		testResult.ErrorMessage = "Connection failed security validation"
		testResult.SecurityIssues = securityResult.Recommendations
		return testResult, nil
	}

	// Attempt connection
	db, err := s.mysqlPort.ConnectToExisting(ctx, s.config)
	if err != nil {
		testResult.ErrorMessage = fmt.Sprintf("Connection failed: %v", err)
		return testResult, nil
	}
	defer db.Close()

	connValidation, err := s.mysqlPort.ValidateConnection(ctx, db)
	if err != nil || !connValidation.IsValid {
		testResult.ErrorMessage = "Connection validation failed"
		return testResult, nil
	}

	tables, err := s.mysqlPort.GetTables(ctx, db, &s.config.DataFiltering)
	if err != nil {
		testResult.Warnings = append(testResult.Warnings, "Could not list tables")
	} else {
		testResult.TableCount = len(tables)
	}

	testResult.Success = true
	testResult.DatabaseName = connValidation.DatabaseInfo["current_database"]
	testResult.ServerVersion = connValidation.ServerInfo["version"]
	testResult.UserName = connValidation.DatabaseInfo["current_user"]

	logrus.Infof("Connection test successful: %s@%s (%d tables)",
		testResult.UserName, testResult.DatabaseName, testResult.TableCount)

	return testResult, nil
}

// GetDataSizeEstimation provides dataset size estimation without full analysis
func (s *DirectDatabaseService) GetDataSizeEstimation(ctx context.Context) (*models.DatasetInfo, error) {
	logrus.Infof("📏 Estimating dataset size")

	db, err := s.mysqlPort.ConnectToExisting(ctx, s.config)
	if err != nil {
		return nil, fmt.Errorf("connection failed: %w", err)
	}
	defer db.Close()

	// Get size estimation
	datasetInfo, err := s.mysqlPort.EstimateDataSize(ctx, db, &s.config.DataFiltering)
	if err != nil {
		return nil, fmt.Errorf("size estimation failed: %w", err)
	}

	return datasetInfo, nil
}

// generateAnalysisSummary creates analysis summary and recommendations
func (s *DirectDatabaseService) generateAnalysisSummary(result *models.DirectDatabaseAnalysisResult) {
	summary := &models.AnalysisSummary{
		TotalTables:     len(result.SchemaAnalysis.Tables),
		TotalRules:      len(result.SchemaAnalysis.GeneratedRules),
		TotalPatterns:   len(result.SchemaAnalysis.GraphPatterns),
		Recommendations: []string{},
		Warnings:        []string{},
	}

	// Count different rule types
	nodeRules := 0
	relationshipRules := 0
	for _, rule := range result.SchemaAnalysis.GeneratedRules {
		switch rule.RuleType {
		case "NODE_CREATION":
			nodeRules++
		case "RELATIONSHIP_CREATION":
			relationshipRules++
		}
	}
	summary.NodeRules = nodeRules
	summary.RelationshipRules = relationshipRules

	// Generate recommendations based on analysis
	if result.SchemaAnalysis.DatasetInfo != nil {
		if result.SchemaAnalysis.DatasetInfo.EstimatedSizeMB > 1000 {
			summary.Recommendations = append(summary.Recommendations,
				"Large dataset detected (>1GB) - consider using batch processing with smaller batch sizes")
		}

		if result.SchemaAnalysis.DatasetInfo.TotalRows > 1000000 {
			summary.Recommendations = append(summary.Recommendations,
				"High row count detected (>1M rows) - enable parallel processing for better performance")
		}
	}

	// Check for potential issues
	if result.ConnectionValidation.HasWritePermissions {
		summary.Warnings = append(summary.Warnings,
			"Database user has write permissions - consider using read-only user for safety")
	}

	if len(result.SchemaAnalysis.GeneratedRules) == 0 {
		summary.Warnings = append(summary.Warnings,
			"No transformation rules were generated - check table structure and relationships")
	}

	// Performance recommendations
	if summary.TotalTables > 50 {
		summary.Recommendations = append(summary.Recommendations,
			"Large number of tables detected - consider using table filtering to focus on important entities")
	}

	result.Summary = summary

	logrus.Infof("Analysis summary: %d tables, %d node rules, %d relationship rules, %d warnings",
		summary.TotalTables, summary.NodeRules, summary.RelationshipRules, len(summary.Warnings))
}

// ValidateConfiguration validates the service configuration
func (s *DirectDatabaseService) ValidateConfiguration() error {
	if s.config == nil {
		return fmt.Errorf("MySQL configuration is nil")
	}

	if s.config.Host == "" {
		return fmt.Errorf("database host is required")
	}

	if s.config.Database == "" {
		return fmt.Errorf("database name is required")
	}

	if s.config.Username == "" && s.config.User == "" {
		return fmt.Errorf("database username is required")
	}

	// Validate security settings
	if s.config.Security.ConnectionTimeout <= 0 {
		s.config.Security.ConnectionTimeout = 30 // Default 30 seconds
	}

	if s.config.Security.QueryTimeout <= 0 {
		s.config.Security.QueryTimeout = 300 // Default 5 minutes
	}

	if s.config.Security.MaxConnections <= 0 {
		s.config.Security.MaxConnections = 5 // Default 5 connections
	}

	return nil
}

// GetConfiguration returns current service configuration
func (s *DirectDatabaseService) GetConfiguration() *models.MySQLConfig {
	return s.config
}

// UpdateConfiguration updates service configuration
func (s *DirectDatabaseService) UpdateConfiguration(config *models.MySQLConfig) error {
	if err := s.validateConfigurationUpdate(config); err != nil {
		return err
	}

	s.config = config

	// Update dependent services
	schemaConfig := &models.SchemaAnalysisConfig{
		GenerateRules:          config.AutoGeneratedRules.Enabled,
		NamingConvention:       config.AutoGeneratedRules.Strategy.NamingConvention,
		TableToNode:            config.AutoGeneratedRules.Strategy.TableToNode,
		ForeignKeysToRelations: config.AutoGeneratedRules.Strategy.ForeignKeysToRelations,
	}
	s.schemaAnalyzer = NewSchemaAnalyzerService(s.mysqlPort, schemaConfig)
	s.securityValidator = NewSecurityValidationService(&config.Security)

	return nil
}

// validateConfigurationUpdate validates configuration before update
func (s *DirectDatabaseService) validateConfigurationUpdate(config *models.MySQLConfig) error {
	if config == nil {
		return fmt.Errorf("configuration cannot be nil")
	}

	// Validate required fields
	required := map[string]string{
		"Host":     config.Host,
		"Database": config.Database,
		"Username": config.Username,
	}

	for field, value := range required {
		if value == "" {
			return fmt.Errorf("field %s is required", field)
		}
	}

	return nil
}
