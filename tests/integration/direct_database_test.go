/*
 * SQL Graph Visualizer - Integration Tests for Direct Database Connection
 *
 * Copyright (c) 2024
 * Licensed under Dual License: AGPL-3.0 OR Commercial License
 * See LICENSE file for details
 * Patent Pending - Application filed for innovative database transformation techniques
 */

package integration

import (
	"context"
	"database/sql"
	"fmt"
	"os"
	"testing"
	"time"

	"sql-graph-visualizer/internal/application/services"
	"sql-graph-visualizer/internal/domain/models"
	"sql-graph-visualizer/internal/infrastructure/persistence/mysql"

	_ "github.com/go-sql-driver/mysql"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/stretchr/testify/suite"
)

// DirectDatabaseIntegrationTestSuite contains integration tests for direct database connection
type DirectDatabaseIntegrationTestSuite struct {
	suite.Suite
	config    *models.MySQLConfig
	mysqlRepo *mysql.MySQLRepository
	dbService *services.DirectDatabaseService
	ctx       context.Context
}

// SetupSuite initializes the test suite with database configuration
func (suite *DirectDatabaseIntegrationTestSuite) SetupSuite() {
	suite.ctx = context.Background()

	// Check if integration tests should run
	if os.Getenv("INTEGRATION_TESTS") != "true" {
		suite.T().Skip("Integration tests skipped - set INTEGRATION_TESTS=true to enable")
	}

	// Setup configuration for Sakila test database
	suite.config = &models.MySQLConfig{
		Host:           "127.0.0.1",
		Port:           3308,
		Username:       "sakila_user",
		Password:       "sakila123",
		Database:       "sakila",
		ConnectionMode: models.ConnectionModeExisting,

		DataFiltering: models.DataFilteringConfig{
			SchemaDiscovery:  true,
			RowLimitPerTable: 100,
			TableBlacklist:   []string{"film_text"}, // Skip full-text table for faster tests
		},

		Security: models.SecurityConfig{
			ReadOnly:          true,
			ConnectionTimeout: 30,
			QueryTimeout:      60,
			MaxConnections:    3,
		},

		AutoGeneratedRules: models.AutoGeneratedRulesConfig{
			Enabled: true,
			Strategy: &models.RuleGenerationStrategy{
				TableToNode:            true,
				ForeignKeysToRelations: true,
				NamingConvention: &models.NamingConvention{
					NodeTypeFormat:     "Pascal",
					RelationTypeFormat: "UPPER_SNAKE",
				},
			},
		},
	}

	// Initialize repository and service
	mysqlRepo := mysql.NewMySQLRepository(nil)
	suite.mysqlRepo = mysqlRepo.(*mysql.MySQLRepository)
	suite.dbService = services.NewDirectDatabaseService(mysqlRepo, suite.config)

	// Validate that test database is available
	err := suite.validateTestDatabase()
	require.NoError(suite.T(), err, "Test database should be available")
}

// validateTestDatabase checks if the test database is running and accessible
func (suite *DirectDatabaseIntegrationTestSuite) validateTestDatabase() error {
	dsn := fmt.Sprintf("%s:%s@tcp(%s:%d)/%s",
		suite.config.Username,
		suite.config.Password,
		suite.config.Host,
		suite.config.Port,
		suite.config.Database,
	)

	db, err := sql.Open("mysql", dsn)
	if err != nil {
		return fmt.Errorf("failed to open database connection: %w", err)
	}
	defer db.Close()

	ctx, cancel := context.WithTimeout(suite.ctx, 5*time.Second)
	defer cancel()

	if err := db.PingContext(ctx); err != nil {
		return fmt.Errorf("failed to ping database: %w", err)
	}

	return nil
}

// TestConnectionValidation tests basic connection functionality
func (suite *DirectDatabaseIntegrationTestSuite) TestConnectionValidation() {
	suite.Run("ValidConfiguration", func() {
		err := suite.dbService.ValidateConfiguration()
		assert.NoError(suite.T(), err)
	})

	suite.Run("QuickConnectionTest", func() {
		result, err := suite.dbService.TestConnection(suite.ctx)
		require.NoError(suite.T(), err)
		require.NotNil(suite.T(), result)

		assert.True(suite.T(), result.Success)
		assert.Equal(suite.T(), "sakila", result.DatabaseName)
		assert.Contains(suite.T(), result.ServerVersion, "8.0")
		assert.Contains(suite.T(), result.UserName, "sakila_user")
		assert.Greater(suite.T(), result.TableCount, 10)
	})

	suite.Run("DetailedConnectionTest", func() {
		// Test with detailed security validation
		result, err := suite.dbService.TestConnection(suite.ctx)
		require.NoError(suite.T(), err)

		assert.True(suite.T(), result.Success)
		assert.Empty(suite.T(), result.SecurityIssues)
	})
}

// TestSchemaAnalysis tests comprehensive schema discovery and analysis
func (suite *DirectDatabaseIntegrationTestSuite) TestSchemaAnalysis() {
	suite.Run("FullSchemaAnalysis", func() {
		result, err := suite.dbService.ConnectAndAnalyze(suite.ctx)
		require.NoError(suite.T(), err)
		require.NotNil(suite.T(), result)

		// Validate basic result structure
		assert.True(suite.T(), result.Success)
		assert.Empty(suite.T(), result.ErrorMessage)
		assert.NotNil(suite.T(), result.DatabaseInfo)
		assert.NotNil(suite.T(), result.SchemaAnalysis)
		assert.NotNil(suite.T(), result.Summary)

		// Validate database info
		assert.Equal(suite.T(), "sakila", result.DatabaseInfo.Database)
		assert.Equal(suite.T(), 3308, result.DatabaseInfo.Port)
		assert.Contains(suite.T(), result.DatabaseInfo.Version, "8.0")

		// Validate schema analysis
		assert.Greater(suite.T(), len(result.SchemaAnalysis.Tables), 10)
		assert.Equal(suite.T(), "sakila", result.SchemaAnalysis.DatabaseName)

		// Validate processing time
		assert.Greater(suite.T(), result.ProcessingDuration, time.Millisecond*10)
		assert.Less(suite.T(), result.ProcessingDuration, time.Second*30)
	})

	suite.Run("TableDiscovery", func() {
		result, err := suite.dbService.ConnectAndAnalyze(suite.ctx)
		require.NoError(suite.T(), err)

		tables := result.SchemaAnalysis.Tables
		assert.Greater(suite.T(), len(tables), 10)

		// Check for expected Sakila tables
		expectedTables := []string{"actor", "film", "customer", "rental", "inventory"}
		foundTables := make(map[string]bool)

		for _, table := range tables {
			foundTables[table.Name] = true
		}

		for _, expected := range expectedTables {
			assert.True(suite.T(), foundTables[expected], "Expected table %s should be found", expected)
		}
	})
}

// TestSuite runs all integration tests
func TestDirectDatabaseIntegration(t *testing.T) {
	suite.Run(t, new(DirectDatabaseIntegrationTestSuite))
}
